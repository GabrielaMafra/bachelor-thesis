% -*- TeX-master: "tccudesc.tex" -*-
\chapter{O gerador de código}
\label{cap3}

Dada uma especificação na linguagem \TLAA, contendo elementos da lógica TLA e da
teoria de conjuntos, além de elementos sintáticos próprios, deseja-se obter uma
definição equivalente em linguagem de programação. Equivalência para esse
propósito é definida pela igualdade do conjunto de comportamentos permitidos.
Isto é, todo comportamento especificado deve ser permitido na execução do
código, e todo comportamento permitido pela execução do código deve ter sido
especificado. Para isso, são feitos mapeamentos de subconjuntos dessas classes
(especificações e códigos),
que combinados mapeiam um subconjunto maior e, potencialmente, todas as
especificações possíveis. 

\section{Elixir}
\label{elixir}

Para esse propósito, a linguagem de programação escolhida para o código traduzido foi Elixir. As motivações são expostas abaixo por ordem de relevância na decisão:
\begin{enumerate}
  \item A concorrência é facilitada por ter seu código traduzido para \textit{bytecode} da máquina virtual do Erlang (BEAM). Suporte a concorrência é de extrema importância, já que \TLA foi criado para facilitar a especificação de sistemas concorrentes. É necessário que o código gerado seja capaz de refletir o sistema também nesse quesito.

  \item Uma linguagem funcional tende a se aproximar mais de definições matemáticas do que linguagens de outros paradigmas. Uma vez que a estrutura de \TLA foi construída principalmente no âmbito da matemática, a complexidade das traduções tende a ser menor para uma linguagem funcional.

  \item O alto nível de abstração da sintaxe de Elixir, que se inspira em Ruby e sua busca por código facilmente entendível, faz com o programador que trabalhar com o código gerado possa entendê-lo de forma mais simples e rápida do que seria com uma linguagem de baixo nível. Com isso, otimizações podem ser feitas com mais segurança, e a manutenabilidade do código é favorecida.

  \item A transparência de plataforma provida pela máquina virtual BEAM maximiza o número de ambientes aonde o código pode ser executado. Não seria de muito uso gerar um código para um ambiente específico, e uma máquina virtual permite que o código gerado seja multiplataforma.

  \item O seu código é aberto sobre a licença Apache 2.0, permitindo que o funcionamento de suas estruturas possa ser verificado a qualquer momento. Não seria possível garantir nenhuma correspondência do código gerado com a especificação se não fosse conhecida a execução gerada pelos operadores usados no código.

\end{enumerate}

Essa escolha vem de encontro com a finalidade de proporcionar um código modificável, de forma que o programador seja capaz de entender a correspondência entre as duas partes e minimizando a diferença do nível de abstração no qual ele está programando.

\section{A tradução}
\label{traducao}

A geração de código para uma especificação se dá pela tradução das estruturas de \TLA para Elixir. Esta tradução é feita de forma automática por uma ferramenta escrita em Haskell, implementada durante o corrente trabalho. A ferramenta é responsável pelo \textit{parsing} do aquivo da especificação, no formato \texttt{.tla}, para estruturas internas e, então, transformação dessas estruturas internas em código Elixir.

A escolha da linguagem Haskell para implementação do gerador de código é motivada pela possibilidade da definição de tipos algébricos, que facilitam na representação das estruturas, e na tipagem forte, que ajuda a garantir consistência das relações entre estruturas definidas durante o processo, minimizando a possibilidade de erros no desenvolvimento. Haskell também conta com a biblioteca de \textit{parsing} Parsec, que abstrai a complexidade de analisar sintaticamente um arquivo.

O escopo da tradução se limita à especificação definida, sendo suficiente para gerar código executável para o sistema definido. Traduzir teoremas e suposições não é necessário, uma vez que essas estruturas servem para fazer verificações sobre a especificação e não são necessárias para seu funcionamento. Ao código gerado não é atribuída a responsabilidade de refazer verificações, e sim de manter as propriedades já verificadas.

\subsection{Mapeamentos}
\label{mapeamentos}

A tradução funciona como um grande mapeamento do conjunto de um conjunto de especificações para um conjunto de programas em Elixir. Para viabilizar esse mapeamento, são definidos sub-mapeamentos que traduzem frações de uma especificação. Encontrar sub-mapeamentos suficientes para atender todo o domínio de especificações é suficiente para definir o processo de tradução.

Os primeiros mapeamentos definidos envolvem fórmulas transicionais e va\-ri\-á\-veis. Para cada fórmula transicional da especificação, é definida uma função, declarada com a sintaxe \texttt{def nome(parametros) do ... end}, que recebe as variáveis como parâmetro. O conjunto de variáveis do sistema é representado em uma hash - estrutura de dados chave-valor de Elixir, equivalente a um dicionário - representada no padrão \texttt{variaveis = \%\{ variavel1: valor1, variavel2: valor2 \}} e podendo ser acessada com \texttt{variaveis[:variavel1]} para obter \texttt{valor1}.

Cada função mapeada de uma ação recebe uma hash representando o estado atual e retorna outra hash representando o novo estado. O retorno em Elixir não exige uma palavra chave - a função retorna aquilo que a última linha retornou, sendo, para as funções geradas, a hash resultante da chamada do seu construtor.

A Figura \ref{fig:esvaziapequeno-elixir} contém a função mapeada da fórmula $EsvaziaPequeno$ definida na Figura \ref{fig:ex1tla}.

\begin{figure}[h]
  \centering
  $\progfig{
  ~~def esvazia\_pequeno(variaveis) do\\
  ~~~~\%\{\\
  ~~~~~~pequeno: 0,\\
  ~~~~~~grande: variaveis[:grande]\\
  ~~~~\}\\
  ~~end
  }$
  \caption{Fórmula transicional $EsvaziaPequeno$ como uma função em Elixir}
\label{fig:esvaziapequeno-elixir}
\end{figure}

Alguns operadores de \TLA permitem mapeamentos ainda mais diretos, como \IF e \CASE, devido a sua inspiração em linguagens de programação. A Figura \ref{fig:pequenoparagrande-elixir} traz a função correspondente à fórmula $PequenoParaGrande$ definida na Figura \ref{fig:ex1tla}. A sintaxe para operadores \IF em Elixir é na forma \texttt{if condição do ... else ... end}.

\begin{figure}[h]
  \centering
  $\progfig{
  ~~def pequeno\_para\_grande(variaveis) do\\
  ~~~~if variaveis[:grande] + variaveis[:pequeno] <= 5 do\\
  ~~~~~~\%\{\\
  ~~~~~~~~pequeno: 0,\\
  ~~~~~~~~grande: variaveis[:grande] + variaveis[:pequeno]\\
  ~~~~~~\}\\
  ~~~~else\\
  ~~~~~~\%\{\\
  ~~~~~~~~pequeno: variaveis[:pequeno] - (5 - variaveis[:grande]),\\
  ~~~~~~~~grande: 5\\
  ~~~~~~\}\\
  ~~~~end\\
  ~~end
  }$
  \caption{Fórmula transicional $PequenoParaGrande$ como uma função em Elixir}
\label{fig:pequenoparagrande-elixir}
\end{figure}

Com o conjunto inicial de mapeamentos apresentado, é possível definir todas as
fórmulas transicionais do sistema definido na Seção \ref{exemplo1}. Ao traduzir
as definições $Init$ e $Next$, é possível executar concorrentemente todos os
comportamentos permitidos pela especificação. A definição $Next$ é traduzida
para a função \texttt{main}, que recebe as variáveis para o estado atual e chama
ela mesma com o novo estado obtido.

A proposta inicial de tradução para a definição $Next$ do \ref{exemplo1},
durante a exploração com traduções manuais, se deu
pelo disparo de um processo para cada passo permitido por $Next$. Como $Next$ é uma disjunção de todas as ações, foi disparado um novo processo com o resultado de cada função traduzida.

Para disparar processos, utilizou-se a função da biblioteca padrão de Elixir responsável por executar processos ligados: \texttt{spawn\_link}. Essa função foi chamada com três parâmetros: o módulo que receberá a chamada, a função a ser executada e uma lista contendo seus parâmetros. Para a tradução de $Next$, o módulo é sempre o módulo do arquivo gerado (\texttt{JarrosDeAgua}), a função é sempre \texttt{main} e os parâmetros são o resultado da aplicação de um dos passos permitidos. O último disparo corresponde à aplicação de um passo balbuciante. A definição dessa função encontra-se na Figura \ref{fig:main-ex1}.

\begin{figure}[h]
  \centering
  \progfig{
  ~def main(variaveis) do\\
  ~~~spawn\_link JarrosDeAgua, :main, [grande\_para\_pequeno(variaveis)]\\
  ~~~spawn\_link JarrosDeAgua, :main, [pequeno\_para\_grande(variaveis)]\\
  ~~~spawn\_link JarrosDeAgua, :main, [esvazia\_grande(variaveis)]\\
  ~~~spawn\_link JarrosDeAgua, :main, [esvazia\_pequeno(variaveis)]\\
  ~~~spawn\_link JarrosDeAgua, :main, [enche\_grande(variaveis)]\\
  ~~~spawn\_link JarrosDeAgua, :main, [enche\_pequeno(variaveis)]\\
  ~~~spawn\_link JarrosDeAgua, :main, [variaveis]\\
  ~end\\\\
  ~JarrosDeAgua.main(\%\{\ grande: 0, pequeno: 0 \})
  }
  \caption{Disparo de processos para o sistema de Jarros de Água}
\label{fig:main-ex1}
\end{figure}

A chamada \texttt{JarrosDeAgua.main(\%\{grande: 0, pequeno: 0\})} é a tradução de $Init$. Como esse sistema permite um único estado inicial, apenas uma chamada a \texttt{main} é necessária. Com ela, todos os passos dados para iniciar novos processos terão iniciado com o valor para variáveis que satisfaz a condição inicial. Através da definição de \texttt{main} é também garantido que todos os passos satisfazem $\square [Next]_{vars}$. Assim, todos os comportamentos iniciados com essa chamada são permitidos por $Spec$, conforme definida na Seção \ref{exemplo1}.

O código gerado para esse sistema não permite, por si só, a solução do problema - uma vez que a especificação não tratava de uma solução. Entretanto, verificou-se que a invariante $jarro\_grande\ \backslash= 4$ não é satisfeita, e portanto um comportamento que leva à solução é permitido por esse sistema. É possível, apenas para fins exploratórios, encontrar os processos disparados pelo código que correspondem a esses comportamentos. Para isso, uma chamada que encerra o programa é invocada se o predicado da invariante for insatisfeito. Essa verificação é feita em todos os passos do comportamento, e portanto é definida como uma condição na função \texttt{main} como na Figura \ref{fig:invariant-ex1}, que imprime os valores das variáveis com \texttt{IO.puts} e encerra o programa com um código de sucesso através de \texttt{:ok}.

\begin{figure}[h]
  \centering
  $\progfig{
  ~def main(variaveis) do\\
  ~~~if variaveis[:grande] == 4 do\\
  ~~~~~IO.puts "\#\{variaveis[:grande]\} \#\{variaveis[:pequeno]\}"\\
  ~~~~~:ok\\
  ~~~end\\
  ~~~\dots\\
  ~end
  }$
  \caption{Exploração de invariantes no código gerado}
\label{fig:invariant-ex1}
\end{figure}

Com essa tradução inicial, é evidenciada a semelhança entre as definições
matemáticas de \TLA e as estruturas do paradigma funcional presentes em Elixir.
Entretanto, o disparo de múltiplos processos contemplando todos os caminhos
possíveis do sistema não é viável dada a explosão de estados nem possui
aplicação prática de muito valor. Assim, se apresenta a maior dificuldade
encontrada durante o desenvolvimento deste trabalho: como traduzir de forma que
o código gerado permita todos os caminhos e ordens possíveis sem que haja
explosão de estados.

Dentre as soluções, ponderou-se exigir que a especificação determinasse
condições suficientemente restritivas para que o caminho seja sempre
determinístico. Em uma segunda reflexão, isso se mostrou uma péssima abordagem,
já que o valor da especificação é, em muitas vezes, relacionado ao não
determinismo do comportamento. Essa solução foi descartada juntamente com a
primeira abordagem de disparar vários processos, e uma nova abordagem menos
restritiva definindo
escolhas foi implementada, e é desenvolvida na Seção \ref{sec:decisao}. 

\subsection{Condições e Ações}
\label{sec:condicoes}

Na definição de uma ação em \TLAA existem expressões de estado e expressões de
ação (descritas na Seção \ref{sec:tla}). As expressões de estado em uma ação
\FANCYA são predicados que terão valoração verdadeira se e somente se o estado em que \FANCYA
será executada - ou seja, o primeiro estado do passo - seja um estado onde
\FANCYA é permitido. Essas expressões, quando dentro da definição de uma ação,
podem ser interpretadas como condições de ativação dessa ação. A ação só pode ser ativada
se suas condições de ativação forem satisfeitas.

Já uma expressão de ação envolve ambos os estados de um passo: o estado atual e
o próximo estado. Se tratada puramente como uma especificação, esse próximo
estado pode ser entendido como qualquer estado possível especificado, de forma
que, de todos os estados possíveis, a expressão de ação só será verdadeira para
aqueles pares de estado que respeitam a condição por ela determinada. Com essa
perspectiva, as expressões de ação também são condições.

Contudo, no contexto de um programa executável viável, os estados são obtidos de
maneira incremental. No código gerado, o estado inicial é obtido pela definição
do estado inicial da especificação, e os próximos estados são obtidos a partir
da sucessiva aplicação de funções - que representam ações - nesse estado.

Gerar todos os estados possíveis e avaliar uma ``condição de ação'' para cada um dos
passos para então filtrá-los seria uma forma possível de executar o programa, porém
não é viável quando há muitos valores possíveis para as variáveis de estado. Ao
especificar $x' = x + 1$, define-se que todos os pares de estado onde o segundo estado tem o
valor de $x$ igual ao valor $x - 1$ do primeiro estado. Contudo, em uma
implementação, gerar pares de estado que para todos os valores
inteiros e filtrar os que atendem essa condição é
inviável. Nesse contexto, é possível simplesmente gerar os pares de estado válidos e,
considerando que o estado atual é conhecido durante a execução, isso significa apenas
somar 1 ao valor de $x$ para obter o segundo estado do par que satisfaz a ação.

As expressões de ação, no código gerado proposto, são operações efetuadas sobre
um estado que resultam sempre em um novo estado válido. Para isso, elas só são
ativadas quando as condições de ativação (definidas pelas expressões
de estado) são satisfeitas. A divisão
entre expressões de estado, que serão transformadas em condições, e expressões de
ação, que serão transformadas em funções que alteram o estado, é feita pelo
próprio parser já que essas expressões se distinguem na gramática da linguagem
de \TLAA.

\begin{figure}[h]
  \centering
  \includegraphics[width=0.8\textwidth]{fig/GRRecebeMsgEfetive.png}
  \caption{Ação para o recebimento da mensagem ``Efetive'' por um gerenciador de
  recurso}
  \label{fig:recebe-efetive-tla}
\end{figure}
\begin{figure}[h]
  \centering
  $\progfig{
  def gr\_recebe\_msg\_efetive\_condition(variables, g) do\\
  ~~Enum.member?(variables[:msgs], \%\{tipo: "Efetive"\})\\
  end\\\\

  def gr\_recebe\_msg\_efetive(variables, g) do\\
  ~~\%\{\\
  ~~~~estado\_gr: Map.put(variables[:estado\_gr], g, "efetivado"),\\
  ~~~~estado\_gt: variables[:estado\_gt],\\
  ~~~~grs\_preparados: variables[:grs\_preparados],\\
  ~~~~msgs: variables[:msgs]\\
  ~~\}\\
  end\\
  }$
  \caption{Código gerado para a ação $GRRecebeMsgEfetive(g)$}
\label{fig:recebe-efetive-elixir}
\end{figure}


Na especificação do protocolo de efetivação em duas fases, na Figura
\ref{fig:ex3tlap2}, o tradutor transformara cada uma das ações em duas funções:
uma de retorno booleano determinando se a condição de ativação é satisfeita, e
outra retornando o estado resultante da aplicação da ação. A Figura
\ref{fig:recebe-efetive-tla} é um recorte dessa especificação, e será traduzida
nas duas funções expostas na Figura \ref{fig:recebe-efetive-elixir}.


\subsection{Determinando a próxima ação}
\label{sec:decisao}

Como discutido na Seção \ref{sec:protocolo}, a ação de próximo estado $Next$
pode ser atendida por mais de um próximo estado $t$ para o mesmo estado atual $s$.
Isso não é um problema para o TLC, que avalia todos os pares estados possíveis distintos
que atendem as condições da ação, verificando todas as ramificações da árvore de
estados. No programa gerado, contudo, executar uma ação significa fazer possivelmente uma alteração de estado, e
múltiplas alterações de estado não são interessantes para o propósito do
código gerado, conforme discutido na Seção \ref{mapeamentos}.

Assim, é necessário um processo bem definido para decidir qual ação executar a
partir de um estado. Para garantir que seja possível tomar tais decisões sem uma
situação que exija uma escolha, é
necessário que a especificação defina, para cada estado do comportamento, condições de ativação mutualmente
exclusivas para ações disjuntas com próximos estados distintos - isto é,
sempre que há uma disjunção de ações, para todos os estados de um comportamento,
todas as condições de ativação dessas ações devem ser falsas para aquele estado exceto pelas daquelas
que levem ao próximo estado do comportamento.

Uma especificação que atenda essa restrição descreve uma função pura, onde não
há efeitos colaterais e uma mesma entrada, dada pelo estado inicial, sempre gera uma mesma
saída, dada pelo comportamento - sequência de estados - obtido. \TLA permite,
contudo, especificar diversos comportamentos válidos a partir do mesmo estado
inicial, o que possibilita que a sequência de estados possa ser eventualmente modificada por
efeitos colaterais e permanecer válida.

Para garantir que o comportamento satisfaz a especificação, as influências de
efeitos colaterais devem obedecer a função de próximo estado. Isso quer dizer
que as influências são, para cada estado da execução, a escolha de uma ação que
satisfaça a função de próximo estado. Como o estado atual $s$ já é conhecido em
tempo de execução, a influência precisa levar a um estado $t$ tal que $<s,t>$
satisfaça tal função.

Quando é definido o conceito de escolha na Seção \ref{sec:protocolo}, define-se que é possível
que exista apenas um valor possível para $t$ que atenda essa restrição. Isso acontece quando a restrição
de condições de ativação mutualmente exclusivas é respeitada pelo estado atual.
Nesse caso, a influência externa não é necessária, já que é possível decidir o
valor de $t$. Assim, a influência externa só é necessária quando uma escolha é
exigida. Nesses casos, o código gerado estabelece uma troca de mensagens entre o
processo gerado pelo modelo e um novo processo denominado oráculo, que será
responsável por toda influência externa no modelo.

O Algoritmo \ref{alg:decide-action} é responsável por examinar as ações
possíveis e decidir qual será aplicada ao estado atual - seja por uma decisão
pura ou por uma escolha de um influência externa. Ela recebe uma identificação
da ação origem, isto é, a definição cuja disjunção de ações precisa de uma
decisão; e uma lista de ações que contém, para cada ação, um rótulo, o valor da
sua condição de ativação para o estado atual e o próximo estado que sua execução traria.

\begin{algorithm}
\caption{Decisão da próxima ação}\label{alg:decide-action}
\begin{algorithmic}[1]
\Procedure{DecideAção}{origem, ações}
\State $acoes\_possiveis\gets$ ações com condição satisfeita
\State $estados\_distintos\gets$ estados únicos resultantes de $acoes\_possiveis$
\If{tamanho de $estados\_distintos=1$}\Comment{Decisão pura}
\State \textbf{return} primeiro estado em $estados\_distintos$
\Else\Comment{Influência Externa}
\State envie identificações das $acoes\_possiveis$ para o oráculo
\State $acao\_escolhida\gets$ resposta do oráculo
\State \textbf{return} estado resultante de $acao\_escolhida$
\EndIf
\EndProcedure
\end{algorithmic}
\end{algorithm}

Se há apenas um próximo estado possível resultante das aplicações das ações
ativadas, então o algoritmo decide por aquele estado. Caso contrário, ele abre
uma conexão com o oráculo, enviando uma identificação das ações
possíveis. O algoritmo permanece bloqueado até que o oráculo responda a ação
escolhida, e então retorna o próximo estado correspondente àquela ação.


\subsection{Concorrência}

Mesmo \TLA sendo uma linguagem de especificação para sistemas concorrentes, ela
não permite descrições para um \textit{fork} ou disparo de novos
processos. O valor de \TLA para sistemas concorrentes é possibilitar um conjunto
de ordens de execução válido, e não limitar a apenas uma única ordem. Sistemas
concorrentes usualmente apresentam muitos comportamentos distintos, e \TLA
permite especificar um modelo que aceite vários desses comportamentos.

Assim, o modelo em si e sua tradução são sequenciais, e se comportam como uma troca
sucessiva de estados - ele é representado em uma lógica temporal, e por isso
pode ser entendido como um conjunto de estados e transições, e estas são
intrinsecamente lineares. A ordem de execução dessas transições, contudo, é
possivelmente determinada por uma influência externa - e esta, sim, pode possuir
elementos concorrentes.

Considerando o sistema dos Jarros de Água do Capítulo \ref{cap2}, cada passo da
execução exige uma escolha, já que nenhuma ação tem condição de ativação. Uma
forma de fazer essa escolha é através do disparo de vários processos onde cada
um seleciona uma das possíveis ações. Esses processos podem ser representados
como pessoas com intenções diferentes de resolver o problema dos jarros. Não é
possível permitir que mais de uma pessoa (ou processo) altere o estado dos
jarros ao mesmo tempo. É possível, contudo, a partir de uma fila ou de uma
escolha aleatória de pessoas, estabelecer uma ordem de ações sobre os jarros.

Algumas operações computacionais, como a escrita em um endereço de memória,
sequenciam ações, já que não podem ser feitos concorrentemente. Isso não
significa que essas operações não precisam ser levadas em conta quando usadas em
um sistema concorrente. Elas são justamente o ponto onde podem ocorrer problemas
nesse tipo de sistema, nos momentos onde processos paralelos precisam de um
recurso compartilhado e a ordem em que eles o obtém influencia o resultado
final. Por isso, um procedimento de sequenciamento como a ordem de obtenção de um
recurso compartilhado pode acontecer de várias maneiras diferentes, e em razão
disso sua especificação é importante.

Um exemplo mais tangível desse fenômeno pode ser dado pelo protocolo de
efetivação em duas fases, discutido na Seção \ref{sec:protocolo}, onde existem vários gerenciadores de recursos
enviando suas intenções de efetivar ou abortar para um gerenciador de transações
compartilhado entre eles. O gerenciador de transações é um processo sequencial,
mas pode ter vários comportamentos diferentes devido as possíveis ordens que as
mensagens dos gerenciadores de recurso chegam.

\section{Regras de Tradução}
\label{sec:regras}

A partir de especificação escritas em \TLAA conforme a sintaxe da Figura
\ref{fig:notacao-tla}, deseja-se obter um código executável em Elixir com
elementos da Figura \ref{fig:notacao-elixir}. As regras de tradução são
divididas em camadas conforme a recursão das definições, de forma que a
especificação completa é traduzida no código pelas regras $\vdash$.

\input{fig/notation}

Em \TLAA, as definições \FANCYA englobam predicados e ações e, como discutido na
Seção \ref{sec:condicoes}, deseja-se separá-los em condições \ttc\ e ações sobre
os estados \tta. Devido a essas definições com misturas de predicados e ações
serem recursivas, é necessário que haja uma separação recursiva também. Para
isso, ao traduzir uma definição com as regras $\vdash_d$, utiliza-se uma
estrutura intermediária na forma de dupla, contendo uma lista das condições
recursivamente encontradas e traduzidas como primeiro elemento, e das ações como
segundo.

Além das traduções especificadas nas regras desta seção, o gerador de código
também carrega os comentários da especificação, transformando comentários que
antecedem as definições em documentação através das anotações \texttt{@doc} do
Elixir. Também são omitidas das regras traduções básicas de expressões
aritméticas e alguns detalhes implementados para melhorar a legibilidade do
código gerado, como identação e conversão de \textit{casing}. 

A implementação dessas regras, assim como o \textit{parser} e alguns exemplos de
oráculos são disponibilizados em
\url{https://github.com/GabrielaMafra/tla-transmutation}. O repositório é
nomeado como uma referência simbólica a Elixir, que assim como a transmutação,
faz parte da prática ancestral da alquimia.

A Seção \ref{sec:validacao} apresenta exemplos de aplicação das regras
apresentadas nesta seção, e por isso é possivelmente um recurso para melhor
compreendimento do funcionamento do tradutor. Por questão organizacional, as
regras e exemplos são mantidos em seções distintas, mas recomenda-se a
referência entre eles no momento da leitura deste capítulo.

\subsection{Tradução de especificações}

\input{fig/spec_rules}

A tradução de uma especificação para código Elixir é dada pela regra
(\texttt{MOD}) na Figura \ref{fig:t-specification}. O julgamento $\vdash$ é responsável pelo início da tradução, recebendo a
especificação completa e traduzindo cada elemento com o julgamento devido.
A partir dela, um módulo Elixir é obtido, assim como a invocação de sua
função \texttt{main} com o estado inicial traduzido. Dentro do módulo, o oráculo
é disparado e referenciado por uma constante, as constantes são declaradas e as
definições traduzidas formam o restante das funções, juntamente com a função de
próximo estado e a função \texttt{decide\_action} definida pelo Algoritmo \ref{alg:decide-action}.

As definições declaradas são traduzidas pela regra (\texttt{DEF}) (Figura
\ref{fig:t-declaration}) que, a partir das duplas
obtidas recursivamente de uma definição \FANCYAA, cria as funções \texttt{nome\_acao\_condition} 
e \texttt{nome\_acao}, reduzindo as condições com o conector lógico \texttt{and}
e as ações com a função \texttt{merge}, responsável por unificar duas
estruturas do tipo \texttt{Map} - usada para representar estados - em uma só.

A declaração de constantes é traduzida pela regra (\texttt{CONST}), que define,
para cada constante declarada na especificação, um atributo do módulo gerado em
Elixir, a partir do operador \texttt{@}, assim como uma função que permite acessá-la de
fora do módulo. O valor das constantes em \TLA só precisa ser definido para
executar o TLC, e não está presente na especificação. Assim, o código gerado
atribui um valor exemplo da forma ``<Value for C>'' a ser substituído pelo programador.


\subsection{Tradução das definições}

As definições de ações e predicados é recursivamente agregada em uma dupla de
listas. Os predicados encontrados são traduzidos para condições com pelas regras
$\vdash_P$ em (\texttt{COND}) e agregados na primeira lista da dupla, enquanto as ações são
traduzidas em funções sobre o estado pelas regras $\vdash_a$ em (\texttt{ACT}) e agregadas na
segunda lista.

Quando uma definição é invocada dentro de outra definição, como acontece com
$podeEfeitvar$ e $naoEfetivado$ na especificação de transações em bancos de
dados na Figura \ref{fig:ex2tla} e em nas definições de próximo estado apresentadas, aplica-se a regra
$(\texttt{CALL})$, que adiciona a condição e a ação daquela definição às
respectivas listas, incorporando completamente a definição invocada.


\input{fig/declaration}
\subsubsection{Condicionais}

Estruturas \IF definem ações com base em uma condição, e poderiam ser traduzidas
para a disjunção de duas definições com suas próprias condições e ações, de forma que uma das
definições tenha a condição idêntica a condicional de \IF e a outra, sua
negação. A as ações seriam enviadas para o algoritmo de decisão, já que se
encontram em uma disjunção, mas nunca precisariam de uma escolha uma vez que a
condicional torna suas condições mutualmente excludentes.

Para não adicionar
indireções possivelmente confusas e preservar a semelhança com a especificação, contudo, optou-se por utilizar
a própria estrutura \texttt{if} da linguagem destino. As definições dos blocos
\IF e \textsc{else} podem conter tanto condições quanto ações, porém essas não
podem ser mantidas em uma mesma expressão \texttt{if}, já que é necessário
avaliar as condições antes de aplicar as ações. A expressão obtida da ação deve
sempre resultar em uma alteração de estado, e no caso do \texttt{if}, a alteração
dependente de uma condicional. Para que sempre haja o retorno de um novo estado, é necessário avaliar as
condições antes e não durante a ação, e para uma essa ação \IF ser ativável, é necessário
atender as condições de ativação da definição em
\THEN se a condicional for verdadeira, e as condições de ativação de \textsc{else} caso
a condicional seja falsa - ou seja, a condição de ativação também depende da
condicional. Assim, a regra (\texttt{IF}) gera duas estruturas \texttt{if}, uma
para as condições e outra para as ações

\subsubsection{Agregação}

\input{fig/decl_aggr}
Quando as definições são conectadas pelo E lógico ($\land$), aplica-se a regra
(\texttt{AND}) e as listas de
condições e ações para cada definição são concatenadas - essas listas serão
devidamente reduzidas a um elemento válido em outras regras.

Já quando o conector é o OU lógico ($\lor$), é necessário iniciar o processo de decisão
discuto nas Seções \ref{sec:protocolo} e \ref{sec:decisao}. A regra
(\texttt{OR}) não gera nenhuma nova condição, e encapsula o processo de decisão
em uma única ação que se dá pela invocação da função \texttt{decide\_action},
que implementa o Algoritmo \ref{alg:decide-action} e retorna a ação que deve ser
executada. Essa função recebe uma lista com três informações para cada definição conectada
pelo OU, que são geradas pelas regras do julgamento $\vdash_i$.

Dada uma definição, a regra (\texttt{INFO-DEF}) gera uma estrutura \texttt{Map}
com: Uma identificação da definição (gerada por uma função \texttt{show} de
conversão da estrutura para \texttt{string}); A redução das condições
encontradas na definição; e a redução das ações. Entre as definições a serem
enviadas para o algoritmo de decisão, é possível que haja um quantificador
existencial, determinando definições com parâmetros dependentes
de algum valor. Nesse caso, a regra (\texttt{INFO-EX}) define uma chamada para a
função \texttt{map}, que será capaz de gerar as informações conforme os valores
em tempo de execução.


\subsubsection{Tradução de Predicados}

Os predicados em \TLA são fórmulas sobre o estado atual, e são traduzidos pelas
regras $\vdash_p$ para expressões lógicas sobre o estado denominadas condições, e estarão sempre
associados a execução de uma ação. As traduções são bem diretas e mapeiam os
operadores de igualdade, desigualdade e pertence para suas representações em
Elixir. Os operadores de desigualdade $\leq, \geq, <$ e $>$ são omitidos das
regras por serem muito semelhantes às regras (\texttt{PRED-EQ}) e
(\texttt{PRED-INEQ}).

$\ENABLED \FANCYA$ é um predicado que tem valor verdadeiro se e somente
$\FANCYA$ é ativável, isto é, se suas condições de ativação são verdadeiras.
Assim, a sua tradução, feita pela regra (\texttt{PRED-EN}) é a avaliação das condições de $\FANCYA$.

\input{fig/pred_act}

\subsubsection{Tradução de Ações}

As ações definidas em \TLA são fórmulas envolvendo o próximo estado. Em elixir,
os estados são representados com a estrutura chave-valor \texttt{Map} em um parâmetro chamado \texttt{variables}, e uma
ação traduz para uma nova estrutura desse tipo. Assim, ao aplicar a regra (\texttt{ACT-UNCH}) para uma ação do
tipo \UNCHANGED - isto é, o valor da variável no próximo estado permanece o
mesmo - a nova estrutura indica que o valor para aquela chave, que representa a
variável, é o valor que a estrutura anterior tinha para tal chave. A
estrutura anterior é obtida pelo parâmetro \texttt{variables}, e o valor referente à
chave \tti é obtido por \texttt{variables[:i]}.

De forma semelhante, quando há uma modificação do valor da variável na transição
de estado, indicado pelo operador \textit{primed}, a tradução é feita pela regra
(\texttt{ACT-PRIM}) e a estrutura para o próximo estado apresenta o
novo valor para a chave referente à variável sendo modificada.

Nas regras $\vdash_a$, cada ação de \TLA é transformada em uma estrutura do tipo
\texttt{Map}. Essas estruturas são posteriormente agregadas com a função
\texttt{merge}, que teriam um formato como \texttt{Map.merge(variables, Map.merge(\%\{ i: 1 \}, \%\{
  j: 2 \}))}. Para melhorar a legibilidade, após a tradução, o gerador agrega os
valores literais em uma única estrutura, de forma que esse mesmo estado fica
representado como \texttt{Map.merge(variables, \%\{ i: 1, j: 2 \})}.

\subsubsection{Tradução de valores}

\input{fig/values}

O mapeamento de valores é a camada mais baixa da tradução, e está bastante
ligada a sintaxe. Conjuntos são traduzidos pra estruturas do tipo
\texttt{MapSet}, que armazenam valores únicos em árvores binárias de busca;
registros são traduzidos para estruturas chave-valor \texttt{Map}, e registros
quantificados sobre um valor são traduzidos pela regra (\texttt{REC-EX}) para
uma composição das funções \texttt{map} e \texttt{into}, que irão iterar sobre o
valor sobre qual a quantificação é feita para gerar vários pares chave-valor, e
incluí-los na estrutura \texttt{Map} gerada pelo restante do registro.

Variáveis são acessadas pelo estado disponível no parâmetro \texttt{variables} e
constantes pelo atributo do módulo. Para decidir como traduzir um identificador,
que pode representar uma variável,
uma constante ou um parâmetro da de definição, utiliza-se o contexto $\Gamma$.
Se o contexto indicar que um identificador é um parâmetro, ele é traduzido sem
modificação.

Se ele for uma constante, é necessário verificar se a tradução está
sendo solicitada de uma definição de dentro do módulo ou de fora - como é no
caso da tradução do estado inicial. Se o contexto não tiver informação do
módulo, significa que essa tradução vem de dentro do próprio módulo e então a
constante pode ser acessada como uma constante do módulo, através do prefixo
\texttt{@}. Caso haja uma indicação de módulo, é necessário traduzi-la para a
chamada da função de acesso à constante daquele módulo, através de
\texttt{NomeDoModulo.constante}.

Se o identificador não for nem um parâmetro e nem uma constante, então ele
representa uma variável do estado e pode ser acessado por \texttt{variables[:i]}.

\subsection{Estado Inicial}

Para verificar propriedades no TLC, o \TLA exige uma definição dos estados
iniciais possíveis. Essa definição tem a forma de um predicado sobre um estado
- e não um passo - ou seja, não é uma ação.

Ao definir o predicado sobre estados iniciais para enviá-lo ao TLC, é
possivelmente desejável que mais de um estado atenda-o, de forma que o TLC
inicie a exploração do espaço de estados a partir de mais de um estado. Isso
traria segurança de que, independentemente de quais dos estados iniciais definidos o
programa se encontre no momento que inicia, seu comportamento será válido.

No contexto da execução desse programa, considera-se que não há benefício em
permitir mais de um possível estado inicial. Uma possibilidade de lidar com uma
definição de múltiplos estados iniciais seria delegar a escolha do estado
inicial ao oráculo, porém isso significaria uma interação com o oráculo antes do
início da execução do modelo, sendo que, nesse momento, o programador poderia
fazer a escolha de forma mais simples. Assim, opta-se por encarregar o
programador de definir o predicado para estados iniciais de forma a garantir que
haja apenas um possível estado que satisfaça-o.

Após a ferramenta de tradução ser aplicada em contextos diferentes, será
possível observar de que forma o oráculo é utilizado pelos programadores.
Considera-se que se for comum o oráculo permanecer continuamente rodando e
persistir o estado em que se encontra, é provável que seja interessante delegar a
escolha do estado inicial ao oráculo em caso de reinicialização da execução do
modelo, uma vez que ele pode ser capaz de restaurar o estado ou partes dele com
as informações retidas. Essa é uma análise e possível trabalho a serem feitos
futuramente.

De forma semelhante à tradução de ações, não é viável gerar todos os estados
possíveis e então filtrá-los para encontrar um que atenda o predicado para o
estado inicial. Assim, e exclusivamente nesse momento, deseja-se que o predicado
gere um estado. Para isso, são necessárias regras de tradução que transforem um
predicado na representação de um estado, onde igualdade é convertida para
atribuição. Essas regras são expressadas por $\vdash_{init}$ na Figura
\ref{fig:t-init-next}. O estado inicial gerado é então enviado para a primeira
chamada da função de próximo estado \texttt{main} conforme as regras $\vdash$ em \ref{fig:t-specification}.

\subsection{Função de próximo estado}

A definição $Next$ é traduzida de maneira similar à definição das outras ações,
exceto que o código gerado para a ação resultante é enviado como parâmetro para
uma nova chamada da mesma função. O nome da definição é alterado para
\texttt{main} e a função \texttt{main} gerada é chamada recursivamente,
recebendo sempre um estado e retornando a invocação de \texttt{main} para o
próximo estado gerado. A Figura \ref{fig:t-init-next} apresenta as regras de
tradução $\vdash_{next}$, responsáveis por gerar tal função.

Para que o programador seja capaz de acompanhar a execução do modelo, é também
adicionada uma função de saída que exibe o estado atual sempre que a função
\texttt{main} é invocada.

\input{fig/init_next}

Sintaticamente as definições do estado inicial e da função de próximo estado são
semelhantes à de qualquer ação. Assim, de forma semelhante a uma execução do
TLC, o gerador de código recebe como parâmetro o nome dessas duas definições
para que possa identificá-las e aplicar as regras de traduções devidas.

\section{Aplicação da tradução}
\label{sec:validacao}

Com as regras de tradução definidas na Seção \ref{sec:regras}, é possível
traduzir as especificações do Capítulo \ref{cap2} em código Elixir executável.
Esta seção tem como objetivo demonstrar os resultados, exemplificando a tradução
para os exemplos de especificações dos Jarros de Água (Figura \ref{fig:ex1tla})
e do protocolo de efetivação em duas fases (Figuras \ref{fig:ex3tlap1} e
\ref{fig:ex3tlap2})

\subsection{Jarros de Água}

\input{fig/jarros_ex}
A especificação do sistema de Jarros de Água contém poucos elementos e é ideal
para exemplificar os mapeamentos mais básicos. A tradução do módulo inicia pela
aplicação da regra (\texttt{MOD}) demonstrada na Figura \ref{fig:jarros-ex-mod}.
A especificação não apresenta constantes, descartando a necessidade de aplicar a
regra (\texttt{CONST}).

A definição $TypeOK$ é uma invariante da especificação e, apesar de apresentar
um predicado válido, não representa valor algum para a execução e, portanto, foi
manualmente descartado. O estado inicial definido por $Init$ - conforme identificado como
parâmetro da tradução - e gera a chamada para \texttt{JarrosDeAgua.main}
apresentada. Os parâmetros com os quais a função é chamada são resultado da
aplicação das regras (\texttt{INIT-AND}) e (\texttt{INIT-EQ}), e pela mesma
agregação de literais feita para ações, que omite chamadas de \texttt{Map.merge}
e foi exemplificada na Seção \ref{sec:regras}.

No interior do módulo, são listadas as definições. As definições dessa
especificação se agrupam em duas formas similares: a primeira contendo apenas
modificações de variáveis, e a segunda apresentando uma expressão \texttt{IF}. A
Figura \ref{fig:jarros-ex-def1} demonstra o resultado da tradução para
definições do primeiro grupo, apresentado também na figura.

O segundo grupo de definições traduz para uma condicional de Elixir conforme a
Figura \ref{fig:jarros-ex-def2}. Destaca-se a diferença entre uma ação com uma
expressão \texttt{IF} e um predicado, que gera uma condição. A expressão
$jarro\_grande + jarro\_pequeno \lte 5$ não é uma condição para a execução da
ação, a ação pode ser ativada a qualquer momento. Essa expressão apenas altera
os valores a serem atribuídos às variáveis do próximo estado.

Para ambos os grupos de definições, a regra (\texttt{AND}) é usada para agregar
as condições e ações encontradas para cada linha da definição. Em nenhuma
definição há condições, resultando portanto em uma lista vazia que será
compreendida como \texttt{True} - ou uma expressão que sempre avalia para
\texttt{True} como no caso das definições \IF. Todas as ações utilizam o operador
\textit{primed}, e portanto são traduzidas através da regra (\texttt{ACT-PRIM}).

Por fim, a definição de próximo estado por $Next$, assim como $Init$ identificado através
de um parâmetro do tradutor, é traduzida pela regra (\texttt{NEXT}) conforme a
Figura \ref{fig:jarros-ex-next}. A função \texttt{main} é recursiva, sempre
chamando ela mesma com o próximo estado, sempre imprimindo o estado com que foi
chamada para que seja possível acompanhar suas alterações. A definição $Next$
apresenta ações separadas pelo operador $\lor$, e portanto requer uma decisão.
Como discutido na Seção \ref{sec:decisao}, a decisão é delegada para a função
\texttt{decide\_action}, que recebe uma lista com informações sobre as possíveis
ações.

Essa lista de ações é exemplificada com as informações para as duas primeiras
ações disponíveis, onde a chave \texttt{action} tem como valor uma identificação
daquela ação, \texttt{condition} chama a função de condição que irá retornar se
ela está satisfeita, e \texttt{state} informa qual o novo estado caso a decisão
seja aquela ação.

\subsubsection{Execução}

Devido à ausência de condições, cada mudança de estado - isto é, cada chamada da
função \texttt{main} - exige uma escolha, de forma que a maior parte do
funcionamento do código gerado dependerá da implementação do oráculo. Supondo um
oráculo que escolha sempre uma ação aleatória entre as enviadas a ele, a
execução dos jarros de água se dará pela alteração aleatória de quantidade de
água nos jarros, porém sempre respeitando as mudanças especificadas.

Outra implementação possível para o oráculo é a leitura de alguma entrada que
determine a ação a ser tomada. Com essa implementação, o resultado da execução
pode ser entendido como um jogo ou simulação, onde algum usuário determina uma
ação e observa um resultado, de forma que as restrições impostas pela
especificação funcionem como regras que limitam as operações a serem feitas pelo
usuário.

\subsection{Protocolo de efetivação em duas fases}

\input{fig/protocolo_ex}
A especificação do protocolo tem elementos mais semelhantes a um modelo real,
tal qual um conjunto arbitrário de gerenciadores de recurso podendo realizar
ações em uma alta variedade de ordens. O código gerado a partir dela permite a
execução de um gerenciador de transações, que executa ações escolhidas por
gerenciadores de recursos e mantém o banco de dados consistente.

A tradução do módulo é, como sempre, iniciada pela regra (\texttt{MOD}), e
traduz para um módulo Elixir conforme a Figura \ref{fig:protocolo-ex-mod}. A
constante $GR$ declarada na especificação é traduzida para \texttt{@gr} e
declarada no início do módulo com sua função de acessibilidade \texttt{gr}. As
definições $Mensagens$ e $DFTypeOK$ não tem valor para a execução e são
manualmente removidas antecipadamente. O
estado inicial é convertido em parâmetros para a chamada de
\texttt{EfetivacaoEmDuasFases.main}, mapeando cada valor conforme as traduções
definidas por $\vdash_v$.

Dentre as traduções de definições, exemplifica-se a tradução para
$GTEfetiva$ na Figura \ref{fig:protocolo-ex-def1}. As duas primeiras definições
da conjunção são condições, já que precisam apenas de informações constantes e
do estado atual para serem avaliadas. Essas duas definições serão traduzidas
para condições e declaradas em \texttt{gt\_efetiva\_condition}. As outras
definições são traduzidas na ação que retorna o novo estado. Para as ações com o
operador \textit{primed}, o novo valor é atribuído; e para a ação \UNCHANGED, o
valor de cada variável na tupla no estado atual é atribuído no novo estado.

Exemplificando a tradução de uma definição parametrizada, a Figura
\ref{fig:protocolo-ex-def2} apresenta o código gerado para
$GRRecebeMsgEfetive(g)$. A condição não depende do parâmetro já que apenas
verifica a presença de uma mensagem, o que significa que sempre que essa ação
for ativável, ela será ativável para qualquer valor de $g$. O estado resultante,
contudo, depende do parâmetro, alterando o valor de $estadoGR$ apenas no valor
referente ao parâmetro. O tradutor, contudo, gera as declarações das funções com
os mesmos parâmetros - a omissão de parâmetros não utilizados, como é o caso de
\texttt{g} em \texttt{gr\_recebe\_msg\_efetive} não se mostrou relevante o
suficiente para ser implementada, e esses parâmetros podem ser removidos
posteriormente pelo programador com base em alertas do analisador de código do
Elixir.

Por fim, a tradução da função de próximo estado $DFNext$ é disposta na Figura
\ref{fig:protocolo-ex-next}. As informações para as ações $GTEfetiva$ e
$GTAborta$ são traduzidas de forma semelhante à tradução de $Next$ no problema
dos Jarros de Água. Já as outras ações são quantificadas sobre os gerenciadores
em $GR$, e as informações serão geradas com a regra (\texttt{INFO-EX}),
produzindo a chamada de \texttt{map} que, para cada valor em \texttt{@gr},
aplicará uma função lambda que aplica a regra (\texttt{INFO-ACT}). A
identificação de uma ação com parâmetro utiliza interpolação de \textit{string}
com o operador \texttt{#{}} e a função \texttt{inspect}, que converte as
estruturas de Elixir para \textit{string}. Isso é necessário para que o oráculo
identifique completamente aquela ação, e não receba várias cópias de um mesmo
identificador sem o valor do parâmetro.

\subsubsection{Execução}
Para permitir a execução do modelo, é necessário definir valores para as
constantes. O protocolo depende da constante $GR$ que é o conjunto de
gerenciadores de recurso que poderão efetivar ou abortar durante a execução.
Define-se então um conjunto simples de dois identificadores representando dois
gerenciadores com \texttt{@gr MapSet.new([``g1'', ``g2''])}.

Cada passo da execução do protocolo exigirá uma escolha, delegada ao oráculo.
Com o intuito de validar o modelo gerado para esse exemplo, uma implementação
mais realística do oráculo foi explorada, e o resultado é fornecido como exemplo
junto à implementação do tradutor. Este oráculo funciona como um gerenciador de
transações (GT) do protocolo, se comunicando com os gerenciadores de recurso
(GRs). Os GRs também são implementados com o propósito de validação, e fazem
parte da influência no processo de escolha.

Todos os gerenciadores, GRs e GT, são processos que processam input do usuário
no terminal, ao mesmo tempo que trocam mensagens sobre as ações a serem
escolhidas. O GT, que recebe as mensagens do modelo (por ser essencialmente o
oráculo), divide as possíveis ações em três grupos: as relacionadas a ele mesmo
(como $GTAborta$), as relacionadas ao gerenciador g1 (como $GRPrepara(``g1'')$)
e as relacionadas ao gerenciador g2. Cada grupo de ações é enviado para o
processo correspondente, de forma a serem exibidos para o usuário que decidirá,
dentre as ações do grupo, qual será escolhida.

Quando uma entrada é lida em algum dos processos, a ação escolhida é enviada de
volta ao oráculo, que por sua vez a envia para o modelo e espera por novas
ações. Assim, é possível simular execuções, como por exemplo através dos passos:

\begin{enumerate}
\item Início\\
  \textbf{Estado do Modelo:} \texttt{\small \\
    estado\_gr:\ \%\{``g1'' =\textgreater{} ``trabalhando'', ``g2'' =\textgreater{}
    ``trabalhando''\},\\
    estado\_gt:\ ``inicio'',\\
    g\_rs\_preparados:\ \#MapSet\textless{}[]\textgreater{},\\
    msgs:\ \#MapSet\textless{}[]\textgreater{}\\\\}
  \textbf{Ações possíveis:}\\\texttt{
    \textbf{[GT]:}\ GTAborta\\
    \textbf{[GR1]:}\ GRPrepara(``g1''), GREscolheAbortar(``g1'')\\
    \textbf{[GR2]:}\ GRPrepara(``g2''), GREscolheAbortar(``g2'')\\}
\item GR1 escolhe \texttt{GRPrepara(``g1'')}\\
  \textbf{Estado do Modelo:} \texttt{\small \\
    estado\_gr:\ \%\{``g1'' =\textgreater{} ``preparado'', ``g2'' =\textgreater{}
    ``trabalhando''\},\\
    estado\_gt:\ ``inicio'',\\
    g\_rs\_preparados:\ \#MapSet\textless{}[]\textgreater{},\\
    msgs:\ \#MapSet\textless{}[\%\{gr:\ ``g1'', tipo:\ ``EstouPreparado'' \}]\textgreater{}\\\\}
  \textbf{Ações possíveis:}\\\texttt{
    \textbf{[GT]:}\ GTAborta, GTRecebePrepara(``g1'')\\
    \textbf{[GR1]:}\ \\
    \textbf{[GR2]:}\ GRPrepara(``g2''), GREscolheAbortar(``g2'')\\}
\item GR2 escolhe \texttt{GREscolheAbortar(``g2'')}\\
  \textbf{Estado do Modelo:} \texttt{\small \\
    estado\_gr:\ \%\{``g1'' =\textgreater{} ``preparado'', ``g2'' =\textgreater{}
    ``abortado''\},\\
    estado\_gt:\ ``inicio'',\\
    g\_rs\_preparados:\ \#MapSet\textless{}[]\textgreater{},\\
    msgs:\ \#MapSet\textless{}[\%\{gr:\ ``g1'', tipo:\ ``EstouPreparado'' \}]\textgreater{}\\\\}
  \textbf{Ações possíveis:}\\\texttt{
    \textbf{[GT]:}\ GTAborta, GTRecebePrepara(``g1'')\\
    \textbf{[GR1]:}\ \\
    \textbf{[GR2]:}\ \\}
\item GT escolhe \texttt{GTAborta}\\
  \textbf{Estado do Modelo:} \texttt{\small \\
    estado\_gr:\ \%\{``g1'' =\textgreater{} ``preparado'', ``g2'' =\textgreater{}
    ``abortado''\},\\
    estado\_gt:\ ``termino'',\\
    g\_rs\_preparados:\ \#MapSet\textless{}[]\textgreater{},\\
    msgs:\ \#MapSet\textless{}[\%\{tipo:\ ``Aborte'' \}\%\{gr:\ ``g1'', tipo:\
    ``EstouPreparado'' \}]\textgreater{}\\\\}
  \textbf{Ações possíveis:}\\\texttt{
    \textbf{[GT]:}\\
    \textbf{[GR1]:}\ GRRecebeMsgAborte(``g1'')\\
    \textbf{[GR2]:}\ GRRecebeMsgAborte(``g2'')}
\end{enumerate}

Com esse exemplo, é demonstrada uma possível forma de influenciar o modelo
quando são necessárias escolhas. Caso não faça sentido para o modelo que algo
externo influencie ele em uma determinada decisão, como uma decisão que é
indiferente para todo o sistema, a decisão pode ser forçada na especificação
através de condições mais restritas. Uma sugestão é que se use predicados do
tipo $\NEG\ENABLED\FANCYA$ em definições menos prioritárias que $\FANCYA$.
