\chapter{\TLA}
\label{cap2}

\TLA é uma linguagem de especificação de software, criada por Leslie Lamport \cite{tlahistory} voltada à modelagem de sistemas concorrentes. Ela se propõe a oferecer uma maneira mais simples de escrever um algoritmo, ao utilizar um nível de abstração acima do que há ao escrever código em uma linguagem de programação. Assim, ao programar, não é necessário atentar-se a detalhes de implementação, permitindo o foco no comportamento do algoritmo - e não das suas dependências.

As especificações são descritas em fórmulas lógicas, com pequenas adaptações de sintaxe. Para facilitar a curva de aprendizado para engenheiros, foi criada a linguagem PlusCal \cite{pluscal}, com uma sintaxe semelhante a linguagens de programação imperativas, e que traduz seus programas para \TLA. A linguagem PlusCal não permite especificar sistemas tão complexos quanto os que podem ser escritos diretamente em \TLA, mas, devido à tradução para a linguagem original, aproveita completamente as capacidades dela de verificação de propriedades.

O método de especificação é baseado em máquinas de estados \cite{tlahistory} e, sendo assim, a descrição de um modelo é composta por uma condição inicial, que determina os possíveis estados inciais, e por uma relação de transições, que determina os possíveis estados que podem suceder cada estado em uma execução. Dessa forma, o conjunto de comportamentos especificado é composto por todos os comportamentos cujo estado inicial satisfaz a condição inicial e todas as transições fazem parte relação.

Lamport destaca \cite{hyperbook} que as especificações deveriam ser sobre modelos de uma abstração do sistema, e não algo retirado do próprio sistema. Semelhante à planta de um edifício, a especificação pode ser consultada para obter informações sobre o edifício (ou programa) de forma mais conveniente, além de ser capaz de facilitar uma série de verificações e perceber problemas enquanto a mudança ainda não é inviavelmente custosa.

Sendo assim, uma especificação em \TLA pode ser sobre comportamentos do ambiente no qual o programa funciona - como ao especificar um sistema e verificar possíveis comportamentos indesejáveis, entendendo aonde o programa deve atuar - descrevendo as operações existentes daquele sistema.

Não limitada a definição de um sistema, uma especificação pode incluir comportamentos do programa em si, compostas por operações existentes do sistema e novas operações definidas pelo programa. Em seu livro \cite{specifying-systems}, Lamport define um sistema de memória linear e, então, propõe uma implementação de um programa de escrita através de \textit{cache} que atua sobre um sistema de memória linear. Assim, ele verifica que a especificação da implementação dele satisfaz a especificação do sistema e prova a implementação. Nos exemplos deste capítulo, serão explicadas especificações de sistemas e de implementações.

\section{Lógica Temporal das Ações}

\TLA combina a Lógica Temporal das Ações, TLA (\textit{Temporal Logic of Actions}), proposta por Lamport em \cite{tlaformalization}, com teoria dos conjuntos - mais especificamente, a teoria de conjuntos de Zermelo-Fraenkel (ZFC), como detalhado em \cite{merzlogic}.

Lamport sumariza em \cite{proofsystem} o uso de TLA em \TLA. TLA é uma lógica temporal linear. Em \TLA, as variáveis rígidas do TLA são chamadas constantes, enquanto as flexíveis são chamadas variáveis. As constantes são declaradas com a palavra-chave \CONSTANTS e tem o mesmo valor para todos os estados de um comportamento - podendo diferir entre comportamentos. Já variáveis são declaradas com a palavra-chave \VARIABLES e podem ter valores diferentes em cada estado de um comportamento.

Os operadores são classificados em constantes e não constantes. Os constantes são aqueles que podem ser escritos em lógica clássica de primeira ordem. Os não constantes dependem de mais fatores, tal como o operador \textit{primed} ('), que depende do valor de uma variável em um estado diferente do atual. As definições em \TLA podem ser categorizadas em tipos de expressão. São denominadas fórmulas todas as expressões com valoração booleana.
\begin{itemize}
  \item \textbf{Expressões constantes} são expressões com apenas constantes declaradas e operadores constantes. Pela definição de operador constante, o valor de uma expressão constante depende apenas do valor das constantes contidas nela.
  \item \textbf{Expressões de estado} contém expressões constantes e variáveis declaradas. O valor de uma expressão de estado depende do estado, já que os valores das variáveis são definidos em um estado.
  \item \textbf{Expressões de ação} contém expressões de estado e operadores não constantes. O seu valor depende de um passo - um par de estados. Esse tipo de definição sobre ações dá o nome \textit{actions} a TLA, e pode ser chamado simplesmente de ação.
  \item \textbf{Expressões temporais} são permitidas apenas com valoração booleana em \TLA, sendo assim, chamadas sempre de fórmulas temporais. Elas contém expressões de ação os operadores $\square$ e $\Diamond$ da lógica temporal (definidos posteriormente neste capítulo). O valor de uma fórmula temporal depende de uma sequência de passos - um comportamento.
\end{itemize}

Com essa estrutura, toda a complexidade das definições estão nas fórmulas de ações. Os operadores temporais são usados somente no momento de verificar propriedades de segurança, vivacidade e razoabilidade (\textit{fairness}).

Uma fórmula temporal em TLA é verdadeira ou falsa em um comportamento, que é definido por uma sequência infinita de estados. Uma fórmula é dita válida se e somente se ela é verdadeira para todos os comportamentos. Uma especificação $F$ implementa outra especificação $G$ se e somente se qualquer sistema que satisfaz $F$ também satisfaz $G$, ou seja, a fórmula $G \implies F$ é válida.

Aos operadores de TLA, são atribuídos os seguintes significados \cite{tlaformalization}:
\begin{itemize}
  \item \ENABLED \FANCYA (\FANCYA é ativável) para uma ação \FANCYA é um predicado cujo valor é verdadeiro para um estado $s$ se e somente se é possível fazer um passo \FANCYA partindo de $s$. Isto é, existe um estado $t$ tal que o passo $s \rightarrow t$ satisfaz \FANCYA.

  \item $\square F$ ($F$ é sempre verdadeiro) para uma fórmula temporal $F$ é satisfeito por um comportamento se e somente se $F$ é verdadeiro para todos os sufixos (primeiro estado em uma passo) do comportamento.

  \item A fórmula $\square [\FANCYA]_f$ para uma ação $\FANCYA$ é satisfeita por um comportamento se e somente se cada passo do comportamento satisfaz \FANCYA ou mantém o valor de $f$, ou seja, $f' = f$.

  \item $\Diamond F$ (Eventualmente F) é definido como $\neg \square \neg F$.

  \item $F \leadsto G$ (Em qualquer momento em que $F$ for verdadeiro, $G$ eventualmente será) é definido como $\square(F \implies \Diamond G)$

  \item $F \stackrel{+}\rightarrow G$ para fórmulas temporais $F$ e $G$ é verdadeiro para um comportamento se e somente se $G$ é verdadeiro, pelo menos, enquanto $F$ é.

  \item \UNCHANGED $f$ ($f$ não é modificado) para uma fórmula de estado $f$ em um passo (par de estados) é definido como $f' = f$  (o valor de $f$ no estado atual é igual ao valor de $f$ no próximo estado).

  \item \EE $x : F$ para uma variável $x$ e uma fórmula temporal $F$ é satisfeito por comportamento se e somente se existem alguns valores a serem atribuídos a $x$ que produzem um comportamento que satisfaz $F$. Esse operador é uma especialização do quantificador existencial comum $\E$ porque ele asserte a existência de uma sequência infinita de valores para $x$, e não um único valor.

  \item \CHOOSE $x : P$ (escolha algum $x$ que satisfaça $P$) para uma variável $x$ e um predicado $P$ resulta em algum valor de $x$ que satisfaz $P$ se \EE $x : P$ for verdadeiro. Sobre \CHOOSE, e possível afirmar que se \EE $x : P$ então $P(\CHOOSE x : P)$ é verdadeiro, e que para todo predicado $Q$ tal que $Q \equiv P$, é verdade que $(\CHOOSE x : P) = (\CHOOSE x : Q)$.

  \item $f \EXCEPT ![v] = e$ para uma função $f$, um elemento de seu domínio $v$ e uma expressão $e$ é definida por $[x \in D \mapsto \IF x = d\ \textsc{THEN}\ e\ \textsc{ELSE}\ f[x]]$ onde $D$ é o domínio de $f$. Ou seja, o valor da expressão \EXCEPT é uma cópia de $f$ exceto pelo valor $f[v]$ que é igual a $e$.

  \item \ASSUME $c$ (assuma $c$) para uma fórmula constante $c$ define $c$ como verdadeiro. Esse operador não tem nenhum efeito nas definições de uma especificação, apenas pode facilitar a verificação de teoremas.
\end{itemize}

Além deles, existem os operadores lógicos $\land,\ \lor$ e $\neg$ com seus significados padrões, assim como os operadores \IF e \CASE.

%% CHOOSE EXCEPT
\subsection{Passos balbuciantes}

Os passos balbuciantes (\textit{stuttering steps}) são parte importante das especificações em \TLA. Eles permitem que o estado - formado pelos valores das variáveis da especificação - se mantenha igual durante um passo.

Supondo que as variáveis da especificação estejam declaradas como
\[vars = <var_1, var_2, \dots, var_n>\]

Então é possível usar o operador $\square [\FANCYA]_f$ definido, com $f = vars$, no seguinte teorema sobre uma especificação $Spec$

\[\THEOREM Spec \implies \square [\FANCYA]_{vars}\]

o que, se verificado, garante que cada passo de um comportamento satisfeito por $Spec$ satisfaz a ação \FANCYA ou é um passo balbuciante e mantém os valores das variáveis em $vars$.

\section{Propriedades}

Sobre uma especificação definida, \TLA permite a verificação de algumas propriedades de segurança e vivacidade. Essas propriedades são descritas em forma de teoremas na especificação apenas com o intuito de documentar sua verificação, porém devem ser inseridas manualmente no modelo TLC para serem, de fato, checadas.

Propriedades são fórmulas temporais sobre ações definidas na especificação. Uma propriedade é satisfeita se a fórmula temporal que a define é válida.

\subsection{Propriedades de Segurança}

Propriedades de segurança define o que o sistema pode fazer. Quando uma propriedade de segurança é violada, ela é violada em um instante específico de um comportamento. Esse tipo de propriedade é definido em \TLA através de invariantes.

Uma invariante é um predicado $P$ que é verdadeiro em todos os passos de todos os comportamentos permitidos por uma especificação $Spec$, e pode ser verificada através do teorema

\[\THEOREM Spec \implies \square P\]

\subsection{Propriedades de Vivacidade}

Propriedades de vivacidade definem o que o sistema deve fazer. Quando uma propriedade de vivacidade é violada, ela é violada em um comportamento. Em \cite{specifying-systems}, é apresentada uma especificação para um relógio. O ponteiro de um relógio deve, eventualmente, mexer. Esse é um tipo de propriedade que pode ser descrita com uma propriedade de vivacidade, tal qual a razoabilidade fraca (\textit{weak fairness}).

A razoabilidade fraca para uma fórmula de estado $f$ e uma ação \FANCYA é escrita como $WF_f (\FANCYA)$. Ela é satisfeita por um comportamento se e somente se \FANCYA $\land\ (f' \neq f)$ é infinitamente não ativável (\textsc{enabled}) ou infinitos passos \FANCYA $\land\ (f' \neq f)$ ocorrem. Sendo assim, essa propriedade garante que \FANCYA não possa permanecer continuamente ativável para sempre sem que um passo \FANCYA ocorra. Essa condição pode ser escrita de forma equivalente como

\[\square (\ENABLED \FANCYA \implies \Diamond[\FANCYA]_f)\]

A conjunção com $(f' \neq f)$ se deve ao fato de não ser desejável exigir que passos balbuciantes eventualmente ocorram. \FANCYA $\land\ (f' \neq f)$ pode ser lido como "todos os passos não balbuciantes que satisfazem \FANCYA".

A razoabilidade fraca recebe a denominação "fraca" porque exige que uma ação permaneça continuamente ativável para garantir a ocorrência de um passo satisfazendo-a. Se um comportamento repetidamente tornar a ação ativável e em seguida não ativável, a razoabilidade fraca não garante nada sobre a ocorrência da ação neste comportamento. Para tal, é necessário garantir a propriedade de razoabilidade forte (\textit{strong fairness}).

A razoabilidade forte para uma fórmula de estado $f$ e uma ação \FANCYA é escrita como $SF_f (\FANCYA)$ . Ela é satisfeita por um comportamento se e somente se \FANCYA $\land (f' \neq f)$ ocorre finitas vezes ou infinitos passos \FANCYA $\land (f' \neq f)$ ocorrem. Essa propriedade garante que \FANCYA não possa ser repetidamente ativável para sempre sem que um passo \FANCYA ocorra.Uma forma equivalente de representar essa condição é

\[\square \Diamond \ENABLED \FANCYA \implies \square \Diamond[\FANCYA]_f\]

que pode ser lida como "se sempre \FANCYA for eventualmente ativável, então sempre um passo $[\FANCYA]_f$ deve eventualmente ocorrer".

\section{Exemplo 1 - Jarros de Água}
\label{exemplo1}

Para exemplificar uma especificação de um sistema, é possível definir um problema combinatório simples como o dos jarros de água. Nesse problema, são fornecidos dois jarros inicialmente vazios, um com capacidade de 3 litros e outro com capacidade de 5 litros, assim como uma fonte inesgotável de água. Sendo assim, é possível despejar a água dos jarros no chão, transferir a água de um jarro ao outro ou encher um jarro com a fonte de água.

O objetivo do problema é ter exatamente 4 litros de água em um dos jarros. Isso é, dada uma máquina de estados, é necessário encontrar uma sequência de transições que leva a algum estado onde o jarro maior tem exatamente 4 litros de água. No entanto, para esse exemplo, deseja-se apenas especificar os comportamentos do sistema em si, e não de um possível programa que buscaria atingir esse objetivo. Uma possível especificação em \TLA para esse sistema se encontra na Figura \ref{fig:ex1tla}.

\begin{figure}
  \centering
  \includegraphics[width=\textwidth]{JarrosDeAgua.png}
  \caption{Especificação do problema dos Jarros de Água}
  \label{fig:ex1tla}
\end{figure}

Entendendo essa especificação no modelo de máquina de estado, é possível observar que as variáveis (\VARIABLES) são um conjunto de valores que variam nos estados, de forma que o conjunto com todas as combinações dos valores possíveis para cada uma das variáveis forma o conjunto de estados da máquina. Um estado desse sistema seria $jarro\_pequeno = 0, jarro\_grande = 1$. Na definição $Init$, é especificada uma fórmula que determina estados iniciais válidos - o que, nesse caso, é apenas o estado onde todas as variáveis do sistema tem valor 0.

As seis definições seguintes representam as transições através de ações. Em cada uma delas, as variáveis com o símbolo de linha representam os valores no estado seguinte, e sempre precisam ser definidas. Na transição $EnchePequeno$, o valor de $jarro\_grande$ se mantém o mesmo entre os estados atual e seguinte, mas é necessário explicitar isso com $jarro\_grande' = jarro\_grande$. Essa necessidade vem da aproximação da sintaxe de \TLA com a matemática, onde não existe efeito colateral e, portanto, o valor da variável $jarro\_grande$ não propaga de um estado para outro.

É possível, sintaticamente, utilizar a informação das variáveis do estado atual para definir o estado seguinte - não é necessário definir exaustivamente transições para todas as combinações de variáveis. Dessa forma, as ações definidas representam transições para vários estados do sistema. Cada transição da especificação do problema dos jarros pode ser aplicada nos em qualquer um dos estados, isto é: $(jarro\_pequeno = 0,\ jarro\_grande = 0), (jarro\_pequeno = 0,\ jarro\_grande = 1), \dots$.

No sentido de aproveitar informações do estado atual, é possível utilizar condicionais, como nas ações $PequenoParaGrande$ e $GrandeParaPequeno$. Com isso, é fácil definir transições diferentes para conjuntos de estados com propriedades diferentes. Na definição de $PequenoParaGrande$, os estados que atualmente possuem 5 litros ou menos de água nos jarros em total recebem uma transição para um estado onde o jarro pequeno está vazio. Já os estados que possuem mais de 5 litros de água recebem uma transição para um estado onde o jarro grande está cheio.

Ao fim dessa especificação, em $Next$, é definida a \textit{next state function} (função de próximo estado), na qual são declaradas as fórmulas transicionais do sistema, incluindo qualquer composição dessas fórmulas que possa levar um estado a outro. No caso do problema dos jarros, apenas é definido que qualquer transição pode ser utilizada para obter um novo estado.

As definições $Init$ e $Next$ são buscadas pelo \textit{model checker} TLC na construção da máquina de estados. É possível renomear essas definições, mas é preciso informar ao TLC os novos nomes para o estado inicial e a \textit{next state function}. A especificação - chamada $Spec$ - é descrita a partir dessas definições com a seguinte fórmula temporal:

\[Spec \defeq Init \land \square [Next]_{vars}\]

Onde $vars$ é uma tupla contendo todas as variáveis declaradas. Com essa especificação, o sistema está definido. As operações permitidas e as variáveis relevantes foram descritas e, a partir do estado inicial, cada passo do sistema pode ser executado a partir de uma das seis diferentes ações ou de passos balbuciantes sobre $vars$. Essas informações são suficientes para o TLC fazer verificações sobre o sistema, é apenas necessário definir tais verificações.

A definição $TypeOK$ na especificação apresentada pode ser utilizada para verificar os tipos desse sistema. Ela define que a variável $jarro\_pequeno$ é sempre um inteiro entre 0 e 3, e a variável $jarro\_grande$ é sempre um inteiro entre 0 e 5. Ou seja, $TypeOK$ será verdadeiro se e somente se os valores das variáveis estiverem de acordo com essas restrições. Isso não é uma verificação em si, e sim uma definição. Para que essa definição seja verificada em todos os estados alcançáveis pelo sistema, é necessário adicioná-la como uma invariante do modelo. Como uma invariante, o valor dela não deve ser modificado em nenhum estado da execução. Já que o estado inicial definido em $Init$ faz $TypeOK$ verdadeiro, ao colocar essa invariante, todos os estados devem fazer $TypeOK$ verdadeiro, ou o TLC retornará um erro. $TypeOk$ pode ser definido como uma invariante através do teorema:

\[\THEOREM Spec \implies \square (TypeOK)\]

Outra propriedade interessante de ser verificada para esse problema antes da implementação de um programa para resolvê-lo é a possibilidade de resolução, isto é, se é possível alcançar um estado onde onde o jarro maior contém 4 litros de água. Para isso, define-se uma invariante para o predicado $jarro\_grande\ \backslash= 4$, que não será satisfeita. Como esse predicado é verdadeiro para o estado inicial, o fato de ele não ser satisfeito significa que, em algum momento da execução, o predicado foi falso, ou seja, $jarro\_grande = 4$. Adicionando essa invariante, um possível teorema seria:

\[\THEOREM Spec \implies \square (TypeOK \land jarro\_grande\ \backslash= 4)\]

O TLC, ao encontrar uma execução que insatisfaz a invariante, traz a sequência de transições que levam ao estado onde o predicado é falso, o que, no caso do simples problema dos jarros, é a solução buscada.

Esse exemplo é apresentado com o intuito de demonstrar a estrutura da especificação de um sistema e o funcionamento das invariantes. A seguir, é proposto um exemplo com especificações de um sistema real e de um protocolo implementado sobre ele.

\section{Exemplo 2 - Transações em Bancos de Dados}

Já tratando de um contexto de um problema real de sistemas concorrentes, define-se uma especificação para o problema da consistência das transações em bancos de dados. Esse é um problema clássico onde, dado um conjunto de gerenciadores de recursos fazendo operações sobre um mesmo banco, um gerenciador só pode cometer (fazer a ação \textit{commit}) se todos os outros gerenciadores estiverem preparados para cometer, e se algum gerenciador quiser abortar, então todos devem abortar. Ou seja, em nenhum momento pode haver um gerenciador abortado e outro cometido.

\subsection{O sistema}

Na Figura \ref{fig:ex2tla}, encontra-se uma especificação para um sistema de transações consistente. Ela não apresenta uma proposta de solução para o problema, e sim traz uma descrição formal do que significa ser consistente quando se trata de transações. Uma especificação de uma solução para o problema deve implementar essa especificação.

\begin{figure}[h]
  \centering
  \includegraphics[width=\textwidth]{TransacoesBD.png}
  \caption{Especificação de um sistema de transações em bancos de dados}
\label{fig:ex2tla}
\end{figure}

Um gerenciador de recursos pode estar em quatro estados diferentes, como definido em $TBDTypeOK$. Do estado \trabalhando, ele pode ir para o estado \preparado, no sentido de que ele está pronto para cometer; ou então abortar, indo para o estado \abortado. Se todos os gerenciadores estão no estado \preparado, então qualquer um deles pode cometer, indo para o estado \cometido; ou então abortar, indo para o estado \abortado. Contudo, se exite algum gerenciador no estado \cometido, então nenhum outro gerenciador pode abortar.

A possibilidade de um gerenciador $g$ ir do estado \trabalhando\ ao \preparado\ é representada pela ação $Prepara(g)$ onde, se o estado de $g$ é \trabalhando, então o valor da variável $estadoGR$ no novo estado é igual ao seu valor no estado atual, exceto pelo valor de $estadoGR[g]$, que passa a ser \preparado.

A decisão de um gerenciador de abortar ou cometer é representada pela ação $Decide(g)$. Nessa definição, as fórmulas $podeCometer$ e $naoCometido$ são definidas separadamente para minimizar a complexidade cognitiva da especificação - definí-las dentro de $Decide(g)$ seria semanticamente equivalente. $podeCometer$ verifica se todos os estados estão preparados ou cometidos, ou seja, qualquer um pode cometer. Se $podeCometer$ for verdadeiro, e $g$ ainda não cometeu, então $g$ comete - o estado dos gerenciadores passa a ser uma cópia do estado atual exceto por $estadoGR[g]$, que é \cometido. Outra decisão possível, separada da primeira por um operador de disjunção, é a de abortar. Para isso, verifica-se, com a fórmula $naoCometido$, se não há nenhum gerenciador cometido. Se $naoCometido$ for verdadeira, e $g$ ainda não tiver abortado, então o novo estado dos gerenciadores passa a ter $g$ como \abortado.

Com essas fórmulas, é possível definir a \textit{next state function} $TBDNext$, onde um passo do sistema é dado por um gerenciador de recursos no conjunto $GR$ que faz uma ação de preparar ou decidir. A fórmula temporal $TBDSpec$ consiste a especificação do sistema de transações bancárias e tem um formato semelhante à fórmula $Spec$ do exemplo anterior, na Seção \ref{exemplo1}.

Para verificar que o sistema especificado por $TBDSpec$ está de acordo com a restrição do problema - em nenhum momento pode haver um gerenciador abortado e outro cometido - define-se $TBDConsistente$ onde, para cada possível par de gerenciadores de recursos, não é o caso de o primeiro estar abortado e o segundo, cometido. Essa fórmula é uma afirmação sobre um valor da variável $estadoGR$, porém precisa ser verdadeira para todos os valores dessa variável em qualquer comportamento que satisfaça $TBDSpec$. Para isso, ela é definida como uma invariante através do teorema

\[\THEOREM TBDSpec \implies \square(TBDTypeOK \land TBDConsistente)\]

que permite verificar que, se um comportamento satisfaz $TBDSpec$ - isto é, seu estado inicial satisfaz $TBDInit$ e seus passos satisfazem $TBDNext$ - então as fórmulas de estado $TBDTypeOK$ e $TBDConsistente$ são verdadeiras para todas as estados - todos os valores atribuídos para as variáveis - neste comportamento. Sendo satisfeito esse teorema, $TBDTypeOK$ e $TBDConsistente$ são ambos invariantes da especificação.

\subsection{A implementação}
