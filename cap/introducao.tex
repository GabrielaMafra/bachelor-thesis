\chapter{Introdução}
\label{introducao}

Desde a década de 60, com os trabalhos de Floyd e Hoare, são feitos trabalhos com propostas para especificar software formalmente. Com especificações, o grau de confiança na correção do programa aumenta, e se torna possível provar formalmente algumas propriedades, com base na semântica da especificação.

Esses trabalhos, contudo, são direcionados a programas sequenciais. Especificar um software concorrente necessita uma modelagem diferente, e não era possível até os primeiros trabalhos de Leslie Lamport na década de 90.

Os métodos de especificação mais bem sucedidos são baseados em modelar transformações de estados com alguma lógica formal. Pensando em sistemas concorrentes, Lamport propõe uma lógica que estende os termos básicos da lógica temporal para permitir predicados sobre pares de estados, o que ele chama de ações. Essa abstração permite manipular ações e não o sistema temporal puro. Essa lógica é chamada de TLA - \textit{Temporal Logic of Actions}.

Sistemas concorrentes são aqueles onde mais de uma computação acontece no mesmo intervalo de tempo - concorrentemente - podendo ou não interagir entre si. Na lógica temporal, os passos executados por todas essas computações concorrentes são descritos como um comportamento, e definidos por uma sequência infinita de estados. Assim, uma fórmula da lógica pode ser verdadeira ou falsa para um comportamento, assim como pode ser válida ou não para todos os comportamentos possíveis.

Com essa abordagem, é possível verificar propriedades sobre um sistema especificado. Especificar um sistema significa definir todos os seus comportamentos possíveis. Tratando-se de um sistema concorrente, é esperado que existam muitos comportamentos, e listá-los exaustivamente seria uma tarefa extremamente passível de erro. Para viabilizar a definição dos comportamentos, é empregada uma modelagem semelhante a de uma máquina de estados, onde é definida a fórmula para o estado inicial e as fórmulas para as transições.

Baseando-se na lógica definida como TLA, Lamport propõe a linguagem de especificação formal \TLA (\textit{Temporal Logic of Actions}), com o objetivo de escrever provas formais para sistemas concorrentes da maneira mais simples possível~\cite{tlahistory}. Nessa linguagem, além dos operadores de TLA, são incluídos elementos da teoria de conjuntos e alguns açúcares sintáticos para fórmulas temporais como cláusulas \IF e \textsc{case}.

No viés de permitir verificações de propriedades, surge o \textit{model checker} TLC. Um \textit{model checker} busca todos os estados atingíveis de um modelo, de forma que todos os comportamentos possíveis são verificados. O TLC recebe uma especificação e uma configuração, e verifica se as fórmulas temporais dadas são válidas para a especificação. Se nenhuma fórmula temporal for dada, o TLC checará a presença de erros na semântica de \TLA e de situações de \textit{deadlock}. A checagem de \textit{deadlock} pode ser desativada, já que pode significar terminação em alguns sistemas.

Mais recentemente, outra ferramenta para verificar propriedades de uma especificação está em desenvolvimento : o sistema de provas TLAPS (\textit{TLA Proof System}) \cite{tlaps2010}. Esse sistema permite checar mecanicamente algumas provas, semelhantemente a Coq e Isabelle, mas ainda está incompleto.

A partir das definições de propriedades desejadas e da possibilidade de verificá-las, se torna possível alterar uma especificação no sentido de buscar por otimizações ou propostas diferentes para o sistema e, através das verificações, encontrar potenciais problemas como \textit{bugs} e inconsistências com as propriedades exigidas. Esses benefícios foram reportados pela \textit{Amazon Web Services} ~\cite{amazon}, que afirma ter usado TLA+ em 10 sistemas complexos e, para cada um deles, ter encontrado \textit{bugs} ou adquirido entendimento e confiança para implementar otimizações agressivas.

As especificações escritas, contudo, não possuem nenhum vínculo com a implementação se não pelo entendimento do programador que as escreveu. Outras linguagens de especificação formal com objetivos semelhantes ao TLA+, como Z, B-Method e ASM, fornecem formas de gerar código a partir do modelo. Contudo, até a data da escrita desse texto, não foram encontrados geradores de código a partir de modelos escritos em TLA+, impossibilitando a conversão das especificações em linguagens de programação com garantia de correspondência.

% Com o programa especificado, validado e traduzido para linguagem de programação, é possível aplicá-lo diretamente em casos reais com a garantia de correspondência e, portanto, das propriedades verificadas; ou então melhorar a implementação para uma versão mais otimizada, mas que parte da mesma base - nesse caso, a garantia é reduzida, já que as mudanças não estavam representadas no modelo original. Observações sobre os benefícios da geração de código a partir de modelos de especificação formal já foram verificadas em trabalhos como o estudo de caso em \cite{Leonard2008}.

\section{Objetivos}

Esse trabalho é feito com a intenção de elaborar um método de tradução, através do mapeamento de estruturas e construtores, de especificações formais descritas em TLA+ para código em linguagem de programação com possibilidade de ser executado e modificado; assim como implementar um tradutor que aplique esse método.

\subsection{Objetivos Específicos}
\begin{itemize}
  \item Encontrar mapeamentos entre as estruturas de especificação em TLA+ e estruturas de linguagens de programação
  \item Implementar um gerador de código Elixir, com capacidade de fazer \textit{parsing} de especificações em TLA+ e aplicar os mapeamentos necessários.
\end{itemize}
